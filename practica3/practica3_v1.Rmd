---
title: Identificación de señales de selección positiva y análisis de enriquecimiento
  funcional
author: "Lorena Lorenzo Fernández"
date: "`r Sys.Date()`"
output:
  github_document:
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
  
#Dependencies 
library(vcfR) 
library(rehh)
library(ggplot2)
library(tidyverse)
library(topGO)
library(biomaRt)
```

En los vastos bosques de un territorio salvaje, habita una especie de felino conocida como *Felis inventalis*. Estos ágiles cazadores se desplazan con destreza entre la espesura del bosque, adaptándose a las variadas condiciones del hábitat forestal.

A lo largo del tiempo, estos gatos han colonizado diferentes áreas del bosque, enfrentándose a distintos desafíos y actualmente están distribuidos en dos poblaciones que ocupan los bosques del Norte y del Sur. En los bosques del Norte, las condiciones son más secas y hay una menor densidad de presas potenciales, mientras que, en los bosques del Sur, las condiciones son más húmedas y hay una mayor densidad de presas, principalmente por ser un punto clave en la ruta migratoria de muchas aves.

Para nuestro estudio, queremos comprobar si estas dos poblaciones están sometidas a presiones selectivas diferentes y, en caso afirmativo, identificar si hay un exceso de genes que estén siendo seleccionados para una determinada función. Con este objetivo, hemos conseguido muestrear ambas poblaciones y extraer datos de genoma completo para 20 individuos de cada población.

Los datos, por tanto, consisten en dos VCF (uno por población) que contienen la información de los genotipos en fase de los individuos muestreados para cada una de las variantes genéticas detectadas a lo largo del genoma.

La estructura de la práctica será la siguiente:

1\. Estimación de pi, thetha y Tajima's D

2\. Análisis de iHS

3\. Enriquecimiento funcional

## iHS- Método basado en identificación de señales de EHH 

Como ya hemos visto, iHS es un estadístico que mide la asimetría de la extensión de haplotipos en desequilibrio de ligamiento en dos direcciones opuestas (ancestral-derivado). Por lo tanto, cuanto mayor sea la diferencia entre las dos direcciones, mayor será el valor de iHS.

En este caso, vamos a utilizar el paquete `rehh` para calcular iHS en las dos poblaciones y ver si hay señales de selección positiva en alguna de ellas.

Empezaremos cargando en R los datos que tenemos para cada población:

```{r read_data, message=FALSE, warning=FALSE}
#Read the vcf file 
vcf_sur <- data2haplohh(hap_file= "data3_selection_pop1.vcf", allele_coding="01", vcf_reader= "vcfR")
vcf_norte <- data2haplohh(hap_file= "data3_selection_pop2.vcf", allele_coding="01", vcf_reader= "vcfR")
```

Una vez que tenemos los datos para cada población, vamos a proceder a calcular iHS en cada una de las poblaciones.

### 1. Cálculo del iHS en la población de gatos de SUR

```{r ihs_sur}
#Scan the genome: this function calculates iHH (integrated EHH, area under EHH curve) and iES (integrated EHH per Site, which forms the basis for cross-population comparisons)for each SNP. 
scan_sur <- scan_hh(vcf_sur)

#Calculate iHS values 
ihs_sur <- ihh2ihs(scan_sur, freqbin=0.05 , min_maf=0)

#extract candidate SNPs 
ihs_val_sur <- ihs_sur$ihs %>% na.omit() 
candidates_sur <- ihs_val_sur %>% filter(IHS > 4 | IHS < -4) 

print(candidates_sur)

#plot iHS results 
sur <- ggplot(data = ihs_val_sur, aes(x = POSITION, y = LOGPVALUE)) +
          geom_point(alpha = 0.5, color = ifelse(ihs_val_sur$IHS > 4 | ihs_val_sur$IHS < -4, "red", "grey")) +
          xlab("Position (Mb)") + 
          ylab("log p-value") +
          theme_minimal()

print(sur)
```

### 2. Cálculo del iHS en la población de gatos del NORTE

```{r ihs_norte}
#Scan the genome: this function calculates iHH (integrated EHH, area under EHH curve) and iES (integrated EHH per Site, which forms the basis for cross-population comparisons)for each SNP.
scan_norte <- scan_hh(vcf_norte)

#Calculate iHS values
ihs_norte <- ihh2ihs(scan_norte, freqbin=0.05 , min_maf=0)

#extract candidate SNPs
ihs_val_norte <- ihs_norte$ihs %>% na.omit()
candidates_norte <- ihs_val_norte %>% filter(IHS > 4 | IHS < -4)

print(candidates_norte)

#plot iHS results
norte <- ggplot(data = ihs_val_norte, aes(x = POSITION, y = LOGPVALUE)) + 
        geom_point(alpha = 0.5, color = ifelse(ihs_val_norte$IHS > 4 | ihs_val_norte$IHS < -4, "red", "grey")) + 
        xlab("Position (Mb)") + 
        ylab("log p-value") +
        theme_minimal()

print(norte)
```

## Enriquecimiento funcional

Para esta parte, vamos a imaginar que no hemos encontrado 3 SNPs bajo selección en la población del sur sino bastantes más como candidatos y que hemos cruzado los resultados de las regiones candidatas (regiones outlier para iHS) con la anotación de nuestro genoma de referencia (en nuestro caso es el del gato) para saber qué genes se encuentran en dichas regiones. Como resultado, tenemos una **lista de genes candidatos** y nos queda saber si en esa lista hay funciones enriquecidas, es decir, si en nuestra lista de genes hay **funciones representadas por exceso o por defecto** a lo que cabría esperar en una muestra aleatoria de genes.

AQUI

```{r felcat_ensembl, eval=FALSE, include=FALSE}
#####Get annotation from ensembl.org#####

#read from ensembl.org every felcat ensembl ID:
ensembl <- useMart("ensembl", dataset = "fcatus_gene_ensembl")

#extract the GOterms for every ensembl_id
ensembl_to_go <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "go_id"), mart = ensembl)

write.table(ensembl_to_go, file="felcat_annotation.csv", sep=",", row.names = F)
```

```{r create_candidate_genes, eval=FALSE, include=FALSE}
###In this chunk I am going to invent my candidate gene list in several steps

# Define the desired GO IDs, that is, the GO terms I'm interested in (inmune system-defend to pathogens)
desired_GO_IDs <- c("GO:0016045", "GO:0051607", "GO:0045058")

# Initialize a vector to store the selected gene names
selected_genes <- c()

# Loop through each desired GO ID
for (desired_GO_ID in desired_GO_IDs) {
  # Get gene names associated with the current desired GO ID
  genes_with_desired_GO <- names(go_list)[sapply(go_list, function(x) desired_GO_ID %in% x)]
  
  # Append the gene names to the selected_genes vector
  selected_genes <- c(selected_genes, genes_with_desired_GO)
}

# Remove duplicates in case a gene is associated with multiple desired GO IDs
selected_genes <- unique(selected_genes)

# Set the seed for reproducibility
set.seed(123)

# Define the number of gene names to select randomly
num_genes_to_select <- 10  # Adjust as needed

# Randomly sample gene names from the selected gene names
randomly_selected_genes <- sample(selected_genes, num_genes_to_select, replace = TRUE)

#From the total list of genes (every gene in go_list), I want to extract a random subset
randomly_nonselected_genes <- sample(names(go_list), 100)

#Finally, my candidates genes will be a mix of randomly selected from the total genes present in the felcat annotation and some of my desired genes (those related with inmune response)
genes <- c(randomly_selected_genes, randomly_nonselected_genes)

#Save the list
write.csv(genes, "candidate_genes.csv")
```

Vamos a cargarla a ver qué pinta tiene:

```{r}
ensembl_to_go<- read_csv("felcat_annotation.csv", show_col_types = FALSE)

#make a list with every GO terms per ENSEMBL_ ID. 
go_list <- split(ensembl_to_go$go_id, ensembl_to_go$external_gene_name)

#Comment: By this we get a total of 29550 ensembl_id corresponding to coding genes (19588) + non-coding genes (9468) + pseudogenes (494) according to https://www.ensembl.org/Felis_catus/Info/Annotation
```

```{r}
{r}
#read candidate genes csv
genes<- read.csv("candidate_genes.csv")
genes <- genes$x

#cross the felcat annotation (ensembl_id with its GOterms) with my set of genes, to get a logical factor of true (if the gene is in the set) and false (if its not)
allgenes = factor(as.integer(names(go_list) %in% genes))
names(allgenes) <- names(go_list) #ensure names of allgenes are names of go_list

#####Creating the topGOdata object#####
godata <- new("topGOdata", ontology = "BP", allGenes = allgenes, 
              annotationFun = annFUN.gene2GO, gene2GO = go_list, nodeSize=10)


#####run the overrepresentation test#####
over_test <- runTest(godata, statistic = "fisher")


result_table <- GenTable(godata, Fisher=over_test, topNodes=over_test@geneData[2]) %>% 
        as_tibble() %>% 
        mutate(p.adj = round(p.adjust(as.numeric(gsub("<", "", Fisher)), method="BH"), 4), ontology= "BP") %>% 
        filter(p.adj<0.05) 

#write.table(results_table, file ="enrichment.csv", sep =  ";")

print(result_table)
```
